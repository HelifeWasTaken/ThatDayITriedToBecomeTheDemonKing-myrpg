{
	"Game entity register entry": {
		"scope": "c,cpp",
		"prefix": "entityregister",
		"body": [
			"&ENTITY($1, &create_${2:${1/(.*)/${1:/downcase}/}}, &draw_${2:${1/(.*)/${1:/downcase}/}},",
			"\t\t&destroy_${2:${1/(.*)/${1:/downcase}/}}, &update_${2:${1/(.*)/${1:/downcase}/}}, &handle_${2:${1/(.*)/${1:/downcase}/}}_events)"
		]
	},
	"Game entity structure": {
		"scope": "c,cpp",
		"prefix": "entitystruct",
		"body": [
			"typedef struct ${1:${TM_FILENAME_BASE}} {",
			"    entity_t *entity;",
			"    pausable_clock_t *clock;",
			"    ${2:sfSprite *sprite;}",
			"} ${1:${TM_FILENAME_BASE}}_t;",
			"",
			"void create_${1:${TM_FILENAME_BASE}}(game_t *game, entity_t *entity);",
			"void update_${1:${TM_FILENAME_BASE}}(game_t *game, entity_t *entity);",
			"void draw_${1:${TM_FILENAME_BASE}}(game_t *game, entity_t *entity);",
			"void destroy_${1:${TM_FILENAME_BASE}}(game_t *game, entity_t *entity);",
			"bool handle_${1:${TM_FILENAME_BASE}}_events(game_t *game, entity_t *entity, sfEvent *event);",
		]
	},
	"Game entity implementation": {
		"scope": "c,cpp",
		"prefix": "entityimpl",
		"body": [
			"/*",
			"** EPITECH PROJECT, 2020",
			"** ${2:${TM_FILENAME_BASE}}",
			"** File description:",
			"** Entity",
			"*/",
			"",
			"#include \"stdlib.h\"",
			"#include \"distract/game.h\"",
			"#include \"distract/entity.h\"",
			"#include \"distract/resources.h\"",
			"#include \"distract/graphics.h\"",
			"#include \"SFML/Window.h\"",
			"#include \"SFML/Graphics.h\"",
			"#include \"myrpg/entities.h\"",
			"#include \"myrpg/asset.h\"",
			"#include \"myrpg/define.h\"",
			"$1",
			"",
			"void create_${2:${TM_FILENAME_BASE}}(game_t *game UNUSED, entity_t *entity)",
			"{",
			"    ${2:${TM_FILENAME_BASE}}_t *${2:${TM_FILENAME_BASE}} = malloc(sizeof(${2:${TM_FILENAME_BASE}}_t), 1);",
			"    ${3:sfIntRect rect = IRECT(0, 0, 9133, 379);\n    sfTexture *texture = create_texture(game, \"assets/sprite.png\", &rect);}",
			"",
			"    ${2:${TM_FILENAME_BASE}}->entity = entity;",
			"    ${2:${TM_FILENAME_BASE}}->clock = create_pausable_clock(game);",
			"    ${4:${2:${TM_FILENAME_BASE}}->sprite = create_sprite(texture, NULL);}",
			"    entity->instance = ${2:${TM_FILENAME_BASE}};",
			"}",
			"",
			"void destroy_${2:${TM_FILENAME_BASE}}(game_t *game UNUSED, entity_t *entity)",
			"{",
			"    ${2:${TM_FILENAME_BASE}}_t *${2:${TM_FILENAME_BASE}} = entity->instance;",
			"",
			"    ${5:sfSprite_destroy(${2:${TM_FILENAME_BASE}}->sprite);}",
			"    destroy_pausable_clock(${2:${TM_FILENAME_BASE}}->clock);",
			"    free(${2:${TM_FILENAME_BASE}});",
			"}",
			"",
			"void update_${2:${TM_FILENAME_BASE}}(game_t *game UNUSED, entity_t *entity)",
			"{",
			"    ${2:${TM_FILENAME_BASE}}_t *${2:${TM_FILENAME_BASE}} = entity->instance;",
			"",
			"    ${6:sfSprite_setPosition(${2:${TM_FILENAME_BASE}}->sprite, entity->pos);}",
			"    tick_pausable_clock(${2:${TM_FILENAME_BASE}}->clock);",
			"}",
			"",
			"void draw_${2:${TM_FILENAME_BASE}}(game_t *game UNUSED, entity_t *entity)",
			"{",
			"    ${2:${TM_FILENAME_BASE}}_t *${2:${TM_FILENAME_BASE}} = entity->instance;",
			"",
			"    ${7:sfRenderWindow_drawSprite(game->window, ${2:${TM_FILENAME_BASE}}->sprite, NULL);}",
			"}",
			"",
			"bool handle_${2:${TM_FILENAME_BASE}}_events(game_t *game UNUSED,",
			"    entity_t *entity UNUSED, sfEvent *event UNUSED)",
			"{",
			"    ${8:return (false);}",
			"}",
		]
	}
}